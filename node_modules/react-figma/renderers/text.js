"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var baseNodeMixin_1 = require("../mixins/baseNodeMixin");
var geometryMixin_1 = require("../mixins/geometryMixin");
var layoutMixin_1 = require("../mixins/layoutMixin");
var saveStyleMixin_1 = require("../mixins/saveStyleMixin");
var propsAssign_1 = require("../helpers/propsAssign");
var refMixin_1 = require("../mixins/refMixin");
var exportMixin_1 = require("../mixins/exportMixin");
var blendMixin_1 = require("../mixins/blendMixin");
var isValidSize_1 = require("../helpers/isValidSize");
var isEqualFontStyle_1 = require("../helpers/isEqualFontStyle");
var textNodePropsAssign = propsAssign_1.propsAssign([
    'characters',
    'textAlignHorizontal',
    'textAlignVertical',
    'textAlignVertical',
    'paragraphIndent',
    'paragraphSpacing',
    'autoRename',
    'fontSize',
    'textCase',
    'textDecoration',
    'letterSpacing',
    'lineHeight'
]);
var defaultFont = { family: 'Roboto', style: 'Regular' };
exports.text = function (node) { return function (props) {
    var textNode = node || props.node || figma.createText();
    refMixin_1.refMixin(textNode)(props);
    baseNodeMixin_1.baseNodeMixin(textNode)(props);
    saveStyleMixin_1.saveStyleMixin(textNode)(props);
    layoutMixin_1.layoutMixin(textNode)(props);
    geometryMixin_1.geometryMixin(textNode)(props);
    exportMixin_1.exportMixin(textNode)(props);
    blendMixin_1.blendMixin(textNode)(props);
    var loadedFont = props.loadedFont, _a = props.fontName, fontName = _a === void 0 ? defaultFont : _a;
    if (loadedFont &&
        fontName &&
        loadedFont.family === fontName.family &&
        isEqualFontStyle_1.isEqualFontStyle(loadedFont.style, fontName.style)) {
        if (props.fontName) {
            textNode.fontName = loadedFont;
        }
        if (props.hasDefinedWidth &&
            isValidSize_1.isValidSize(props.width) &&
            isValidSize_1.isValidSize(textNode.height) &&
            !props.textAutoResize) {
            textNode.resize(props.width, textNode.height);
            textNode.textAutoResize = 'HEIGHT';
        }
        else {
            textNode.textAutoResize = props.textAutoResize || 'WIDTH_AND_HEIGHT';
        }
        textNodePropsAssign(textNode)(props);
    }
    return textNode;
}; };
//# sourceMappingURL=text.js.map